"use strict";

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.promise");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BaseScraperWithBrowser = exports.LoginResults = void 0;

var _puppeteer = _interopRequireDefault(require("puppeteer"));

var _baseScraper = require("./base-scraper");

var _navigation = require("../helpers/navigation");

var _elementsInteractions = require("../helpers/elements-interactions");

var _debug = require("../helpers/debug");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

const VIEWPORT_WIDTH = 1024;
const VIEWPORT_HEIGHT = 768;
const OK_STATUS = 200;
const debug = (0, _debug.getDebug)('base-scraper-with-browser');
var LoginBaseResults;

(function (LoginBaseResults) {
  LoginBaseResults["Success"] = "SUCCESS";
  LoginBaseResults["UnknownError"] = "UNKNOWN_ERROR";
})(LoginBaseResults || (LoginBaseResults = {}));

const {
  Timeout,
  Generic,
  General
} = _baseScraper.ScraperErrorTypes,
      rest = _objectWithoutProperties(_baseScraper.ScraperErrorTypes, ["Timeout", "Generic", "General"]);

const LoginResults = _objectSpread({}, rest, {}, LoginBaseResults);

exports.LoginResults = LoginResults;

async function getKeyByValue(object, value, page) {
  const keys = Object.keys(object);

  for (const key of keys) {
    // @ts-ignore
    const conditions = object[key];

    for (const condition of conditions) {
      let result = false;

      if (condition instanceof RegExp) {
        result = condition.test(value);
      } else if (typeof condition === 'function') {
        result = await condition({
          page,
          value
        });
      } else {
        result = value.toLowerCase() === condition.toLowerCase();
      }

      if (result) {
        // @ts-ignore
        return Promise.resolve(key);
      }
    }
  }

  return Promise.resolve(LoginResults.UnknownError);
}

function handleLoginResult(scraper, loginResult) {
  switch (loginResult) {
    case LoginResults.Success:
      scraper.emitProgress(_baseScraper.ScaperProgressTypes.LoginSuccess);
      return {
        success: true
      };

    case LoginResults.InvalidPassword:
    case LoginResults.UnknownError:
      scraper.emitProgress(_baseScraper.ScaperProgressTypes.LoginFailed);
      return {
        success: false,
        errorType: loginResult === LoginResults.InvalidPassword ? _baseScraper.ScraperErrorTypes.InvalidPassword : _baseScraper.ScraperErrorTypes.General,
        errorMessage: `Login failed with ${loginResult} error`
      };

    case LoginResults.ChangePassword:
      scraper.emitProgress(_baseScraper.ScaperProgressTypes.ChangePassword);
      return {
        success: false,
        errorType: _baseScraper.ScraperErrorTypes.ChangePassword
      };

    default:
      throw new Error(`unexpected login result "${loginResult}"`);
  }
}

function createGeneralError() {
  return {
    success: false,
    errorType: _baseScraper.ScraperErrorTypes.General
  };
}

class BaseScraperWithBrowser extends _baseScraper.BaseScraper {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "browser", void 0);

    _defineProperty(this, "page", void 0);
  }

  async initialize() {
    debug('initialize scraper');
    this.emitProgress(_baseScraper.ScaperProgressTypes.Initializing);
    let env;

    if (this.options.verbose) {
      env = _objectSpread({
        DEBUG: '*'
      }, process.env);
    }

    if (typeof this.options.browser !== 'undefined' && this.options.browser !== null) {
      debug('use custom browser instance provided in options');
      this.browser = this.options.browser;
    } else {
      const executablePath = this.options.executablePath || undefined;
      const args = this.options.args || [];
      const headless = !this.options.showBrowser;
      debug(`launch a browser with headless mode = ${headless}`);
      this.browser = await _puppeteer.default.launch({
        env,
        headless,
        executablePath,
        args
      });
    }

    if (this.options.prepareBrowser) {
      debug('execute \'prepareBrowser\' interceptor provided in options');
      await this.options.prepareBrowser(this.browser);
    }

    if (!this.browser) {
      debug('failed to initiate a browser, exit');
      return;
    }

    const pages = await this.browser.pages();

    if (pages.length) {
      debug('browser has already pages open, use the first one');
      [this.page] = pages;
    } else {
      debug('create a new browser page');
      this.page = await this.browser.newPage();
    }

    if (this.options.preparePage) {
      debug('execute \'preparePage\' interceptor provided in options');
      await this.options.preparePage(this.page);
    }

    debug(`set viewport to width ${VIEWPORT_WIDTH}, height ${VIEWPORT_HEIGHT}`);
    await this.page.setViewport({
      width: VIEWPORT_WIDTH,
      height: VIEWPORT_HEIGHT
    });
  }

  async navigateTo(url, page, timeout) {
    const pageToUse = page || this.page;

    if (!pageToUse) {
      return;
    }

    const options = _objectSpread({}, timeout === null ? null : {
      timeout
    });

    const response = await pageToUse.goto(url, options); // note: response will be null when navigating to same url while changing the hash part. the condition below will always accept null as valid result.

    if (response !== null && (response === undefined || response.status() !== OK_STATUS)) {
      throw new Error(`Error while trying to navigate to url ${url}`);
    }
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  getLoginOptions(_credentials) {
    throw new Error(`getLoginOptions() is not created in ${this.options.companyId}`);
  }

  async fillInputs(pageOrFrame, fields) {
    const modified = [...fields];
    const input = modified.shift();

    if (!input) {
      return;
    }

    await (0, _elementsInteractions.fillInput)(pageOrFrame, input.selector, input.value);

    if (modified.length) {
      await this.fillInputs(pageOrFrame, modified);
    }
  }

  async login(credentials) {
    if (!credentials || !this.page) {
      return createGeneralError();
    }

    debug('execute login process');
    const loginOptions = this.getLoginOptions(credentials);

    if (loginOptions.userAgent) {
      debug('set custom user agent provided in options');
      await this.page.setUserAgent(loginOptions.userAgent);
    }

    debug('navigate to login url');
    await this.navigateTo(loginOptions.loginUrl);

    if (loginOptions.checkReadiness) {
      debug('execute \'checkReadiness\' interceptor provided in login options');
      await loginOptions.checkReadiness();
    } else {
      debug('wait until submit button is available');
      await (0, _elementsInteractions.waitUntilElementFound)(this.page, loginOptions.submitButtonSelector);
    }

    let loginFrameOrPage = this.page;

    if (loginOptions.preAction) {
      debug('execute \'preAction\' interceptor provided in login options');
      loginFrameOrPage = (await loginOptions.preAction()) || this.page;
    }

    debug('fill login components input with relevant values');
    await this.fillInputs(loginFrameOrPage, loginOptions.fields);
    debug('click on login submit button');
    await (0, _elementsInteractions.clickButton)(loginFrameOrPage, loginOptions.submitButtonSelector);
    this.emitProgress(_baseScraper.ScaperProgressTypes.LoggingIn);

    if (loginOptions.postAction) {
      debug('execute \'postAction\' interceptor provided in login options');
      await loginOptions.postAction();
    } else {
      debug('wait for page navigation');
      await (0, _navigation.waitForNavigation)(this.page);
    }

    debug('check login result');
    const current = await (0, _navigation.getCurrentUrl)(this.page, true);
    const loginResult = await getKeyByValue(loginOptions.possibleResults, current, this.page);
    debug(`handle login results ${loginResult}`);
    return handleLoginResult(this, loginResult);
  }

  async terminate(_success) {
    debug(`terminating browser with success = ${_success}`);
    this.emitProgress(_baseScraper.ScaperProgressTypes.Terminating);

    if (!_success && !!this.options.storeFailureScreenShotPath) {
      debug(`create a snapshot before terminated in ${this.options.storeFailureScreenShotPath}`);
      await this.page.screenshot({
        path: this.options.storeFailureScreenShotPath,
        fullPage: true
      });
    }

    if (!this.browser) {
      return;
    }

    await this.browser.close();
  }

}

exports.BaseScraperWithBrowser = BaseScraperWithBrowser;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zY3JhcGVycy9iYXNlLXNjcmFwZXItd2l0aC1icm93c2VyLnRzIl0sIm5hbWVzIjpbIlZJRVdQT1JUX1dJRFRIIiwiVklFV1BPUlRfSEVJR0hUIiwiT0tfU1RBVFVTIiwiZGVidWciLCJMb2dpbkJhc2VSZXN1bHRzIiwiVGltZW91dCIsIkdlbmVyaWMiLCJHZW5lcmFsIiwiU2NyYXBlckVycm9yVHlwZXMiLCJyZXN0IiwiTG9naW5SZXN1bHRzIiwiZ2V0S2V5QnlWYWx1ZSIsIm9iamVjdCIsInZhbHVlIiwicGFnZSIsImtleXMiLCJPYmplY3QiLCJrZXkiLCJjb25kaXRpb25zIiwiY29uZGl0aW9uIiwicmVzdWx0IiwiUmVnRXhwIiwidGVzdCIsInRvTG93ZXJDYXNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJVbmtub3duRXJyb3IiLCJoYW5kbGVMb2dpblJlc3VsdCIsInNjcmFwZXIiLCJsb2dpblJlc3VsdCIsIlN1Y2Nlc3MiLCJlbWl0UHJvZ3Jlc3MiLCJTY2FwZXJQcm9ncmVzc1R5cGVzIiwiTG9naW5TdWNjZXNzIiwic3VjY2VzcyIsIkludmFsaWRQYXNzd29yZCIsIkxvZ2luRmFpbGVkIiwiZXJyb3JUeXBlIiwiZXJyb3JNZXNzYWdlIiwiQ2hhbmdlUGFzc3dvcmQiLCJFcnJvciIsImNyZWF0ZUdlbmVyYWxFcnJvciIsIkJhc2VTY3JhcGVyV2l0aEJyb3dzZXIiLCJCYXNlU2NyYXBlciIsImluaXRpYWxpemUiLCJJbml0aWFsaXppbmciLCJlbnYiLCJvcHRpb25zIiwidmVyYm9zZSIsIkRFQlVHIiwicHJvY2VzcyIsImJyb3dzZXIiLCJleGVjdXRhYmxlUGF0aCIsInVuZGVmaW5lZCIsImFyZ3MiLCJoZWFkbGVzcyIsInNob3dCcm93c2VyIiwicHVwcGV0ZWVyIiwibGF1bmNoIiwicHJlcGFyZUJyb3dzZXIiLCJwYWdlcyIsImxlbmd0aCIsIm5ld1BhZ2UiLCJwcmVwYXJlUGFnZSIsInNldFZpZXdwb3J0Iiwid2lkdGgiLCJoZWlnaHQiLCJuYXZpZ2F0ZVRvIiwidXJsIiwidGltZW91dCIsInBhZ2VUb1VzZSIsInJlc3BvbnNlIiwiZ290byIsInN0YXR1cyIsImdldExvZ2luT3B0aW9ucyIsIl9jcmVkZW50aWFscyIsImNvbXBhbnlJZCIsImZpbGxJbnB1dHMiLCJwYWdlT3JGcmFtZSIsImZpZWxkcyIsIm1vZGlmaWVkIiwiaW5wdXQiLCJzaGlmdCIsInNlbGVjdG9yIiwibG9naW4iLCJjcmVkZW50aWFscyIsImxvZ2luT3B0aW9ucyIsInVzZXJBZ2VudCIsInNldFVzZXJBZ2VudCIsImxvZ2luVXJsIiwiY2hlY2tSZWFkaW5lc3MiLCJzdWJtaXRCdXR0b25TZWxlY3RvciIsImxvZ2luRnJhbWVPclBhZ2UiLCJwcmVBY3Rpb24iLCJMb2dnaW5nSW4iLCJwb3N0QWN0aW9uIiwiY3VycmVudCIsInBvc3NpYmxlUmVzdWx0cyIsInRlcm1pbmF0ZSIsIl9zdWNjZXNzIiwiVGVybWluYXRpbmciLCJzdG9yZUZhaWx1cmVTY3JlZW5TaG90UGF0aCIsInNjcmVlbnNob3QiLCJwYXRoIiwiZnVsbFBhZ2UiLCJjbG9zZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTs7QUFFQTs7QUFLQTs7QUFDQTs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUFFQSxNQUFNQSxjQUFjLEdBQUcsSUFBdkI7QUFDQSxNQUFNQyxlQUFlLEdBQUcsR0FBeEI7QUFDQSxNQUFNQyxTQUFTLEdBQUcsR0FBbEI7QUFFQSxNQUFNQyxLQUFLLEdBQUcscUJBQVMsMkJBQVQsQ0FBZDtJQUVLQyxnQjs7V0FBQUEsZ0I7QUFBQUEsRUFBQUEsZ0I7QUFBQUEsRUFBQUEsZ0I7R0FBQUEsZ0IsS0FBQUEsZ0I7O0FBS0wsTUFBTTtBQUNKQyxFQUFBQSxPQURJO0FBQ0tDLEVBQUFBLE9BREw7QUFDY0MsRUFBQUE7QUFEZCxJQUVGQyw4QkFGSjtBQUFBLE1BQ2dDQyxJQURoQyw0QkFFSUQsOEJBRko7O0FBR08sTUFBTUUsWUFBWSxxQkFDcEJELElBRG9CLE1BRXBCTCxnQkFGb0IsQ0FB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RDs7QUFFRFgsSUFBQUEsS0FBSyxDQUFDLG9CQUFELENBQUw7QUFDQSxVQUFNNkYsT0FBTyxHQUFHLE1BQU0sK0JBQWMsS0FBS2xGLElBQW5CLEVBQXlCLElBQXpCLENBQXRCO0FBQ0EsVUFBTWUsV0FBVyxHQUFHLE1BQU1sQixhQUFhLENBQUMyRSxZQUFZLENBQUNXLGVBQWQsRUFBK0JELE9BQS9CLEVBQXdDLEtBQUtsRixJQUE3QyxDQUF2QztBQUNBWCxJQUFBQSxLQUFLLENBQUUsd0JBQXVCMEIsV0FBWSxFQUFyQyxDQUFMO0FBQ0EsV0FBT0YsaUJBQWlCLENBQUMsSUFBRCxFQUFPRSxXQUFQLENBQXhCO0FBQ0Q7O0FBRUQsUUFBTXFFLFNBQU4sQ0FBZ0JDLFFBQWhCLEVBQW1DO0FBQ2pDaEcsSUFBQUEsS0FBSyxDQUFFLHNDQUFxQ2dHLFFBQVMsRUFBaEQsQ0FBTDtBQUNBLFNBQUtwRSxZQUFMLENBQWtCQyxpQ0FBb0JvRSxXQUF0Qzs7QUFFQSxRQUFJLENBQUNELFFBQUQsSUFBYSxDQUFDLENBQUMsS0FBS3BELE9BQUwsQ0FBYXNELDBCQUFoQyxFQUE0RDtBQUMxRGxHLE1BQUFBLEtBQUssQ0FBRSwwQ0FBeUMsS0FBSzRDLE9BQUwsQ0FBYXNELDBCQUEyQixFQUFuRixDQUFMO0FBQ0EsWUFBTSxLQUFLdkYsSUFBTCxDQUFVd0YsVUFBVixDQUFxQjtBQUN6QkMsUUFBQUEsSUFBSSxFQUFFLEtBQUt4RCxPQUFMLENBQWFzRCwwQkFETTtBQUV6QkcsUUFBQUEsUUFBUSxFQUFFO0FBRmUsT0FBckIsQ0FBTjtBQUlEOztBQUVELFFBQUksQ0FBQyxLQUFLckQsT0FBVixFQUFtQjtBQUNqQjtBQUNEOztBQUVELFVBQU0sS0FBS0EsT0FBTCxDQUFhc0QsS0FBYixFQUFOO0FBQ0Q7O0FBdks4QyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBwdXBwZXRlZXIsIHsgQnJvd3NlciwgRnJhbWUsIFBhZ2UgfSBmcm9tICdwdXBwZXRlZXInO1xuXG5pbXBvcnQge1xuICBTY3JhcGVyRXJyb3JUeXBlcyxcbiAgQmFzZVNjcmFwZXIsIFNjYXBlclNjcmFwaW5nUmVzdWx0LCBTY2FwZXJQcm9ncmVzc1R5cGVzLFxuICBTY3JhcGVyQ3JlZGVudGlhbHMsXG59IGZyb20gJy4vYmFzZS1zY3JhcGVyJztcbmltcG9ydCB7IGdldEN1cnJlbnRVcmwsIHdhaXRGb3JOYXZpZ2F0aW9uIH0gZnJvbSAnLi4vaGVscGVycy9uYXZpZ2F0aW9uJztcbmltcG9ydCB7IGNsaWNrQnV0dG9uLCBmaWxsSW5wdXQsIHdhaXRVbnRpbEVsZW1lbnRGb3VuZCB9IGZyb20gJy4uL2hlbHBlcnMvZWxlbWVudHMtaW50ZXJhY3Rpb25zJztcbmltcG9ydCB7IGdldERlYnVnIH0gZnJvbSAnLi4vaGVscGVycy9kZWJ1Zyc7XG5cbmNvbnN0IFZJRVdQT1JUX1dJRFRIID0gMTAyNDtcbmNvbnN0IFZJRVdQT1JUX0hFSUdIVCA9IDc2ODtcbmNvbnN0IE9LX1NUQVRVUyA9IDIwMDtcblxuY29uc3QgZGVidWcgPSBnZXREZWJ1ZygnYmFzZS1zY3JhcGVyLXdpdGgtYnJvd3NlcicpO1xuXG5lbnVtIExvZ2luQmFzZVJlc3VsdHMge1xuICBTdWNjZXNzID0gJ1NVQ0NFU1MnLFxuICBVbmtub3duRXJyb3IgPSAnVU5LTk9XTl9FUlJPUidcbn1cblxuY29uc3Qge1xuICBUaW1lb3V0LCBHZW5lcmljLCBHZW5lcmFsLCAuLi5yZXN0XG59ID0gU2NyYXBlckVycm9yVHlwZXM7XG5leHBvcnQgY29uc3QgTG9naW5SZXN1bHRzID0ge1xuICAuLi5yZXN0LFxuICAuLi5Mb2dpbkJhc2VSZXN1bHRzLFxufTtcblxuZXhwb3J0IHR5cGUgTG9naW5SZXN1bHRzID0gRXhjbHVkZTxTY3JhcGVyRXJyb3JUeXBlcyxcblNjcmFwZXJFcnJvclR5cGVzLlRpbWVvdXRcbnwgU2NyYXBlckVycm9yVHlwZXMuR2VuZXJpY1xufCBTY3JhcGVyRXJyb3JUeXBlcy5HZW5lcmFsPiB8IExvZ2luQmFzZVJlc3VsdHM7XG5cbmV4cG9ydCB0eXBlIFBvc3NpYmxlTG9naW5SZXN1bHRzID0ge1xuICBba2V5IGluIExvZ2luUmVzdWx0c10/OiAoc3RyaW5nIHwgUmVnRXhwIHwgKChvcHRpb25zPzogeyBwYWdlPzogUGFnZX0pID0+IFByb21pc2U8Ym9vbGVhbj4pKVtdXG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIExvZ2luT3B0aW9ucyB7XG4gIGxvZ2luVXJsOiBzdHJpbmc7XG4gIGNoZWNrUmVhZGluZXNzPzogKCkgPT4gUHJvbWlzZTx2b2lkPjtcbiAgZmllbGRzOiB7c2VsZWN0b3I6IHN0cmluZywgdmFsdWU6IHN0cmluZ31bXTtcbiAgc3VibWl0QnV0dG9uU2VsZWN0b3I6IHN0cmluZztcbiAgcHJlQWN0aW9uPzogKCkgPT4gUHJvbWlzZTxGcmFtZSB8IHZvaWQ+O1xuICBwb3N0QWN0aW9uPzogKCkgPT4gUHJvbWlzZTx2b2lkPjtcbiAgcG9zc2libGVSZXN1bHRzOiBQb3NzaWJsZUxvZ2luUmVzdWx0cztcbiAgdXNlckFnZW50Pzogc3RyaW5nO1xufVxuXG5hc3luYyBmdW5jdGlvbiBnZXRLZXlCeVZhbHVlKG9iamVjdDogUG9zc2libGVMb2dpblJlc3VsdHMsIHZhbHVlOiBzdHJpbmcsIHBhZ2U6IFBhZ2UpOiBQcm9taXNlPExvZ2luUmVzdWx0cz4ge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCBjb25kaXRpb25zID0gb2JqZWN0W2tleV07XG5cbiAgICBmb3IgKGNvbnN0IGNvbmRpdGlvbiBvZiBjb25kaXRpb25zKSB7XG4gICAgICBsZXQgcmVzdWx0ID0gZmFsc2U7XG5cbiAgICAgIGlmIChjb25kaXRpb24gaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgcmVzdWx0ID0gY29uZGl0aW9uLnRlc3QodmFsdWUpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY29uZGl0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJlc3VsdCA9IGF3YWl0IGNvbmRpdGlvbih7IHBhZ2UsIHZhbHVlIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gdmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gY29uZGl0aW9uLnRvTG93ZXJDYXNlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShMb2dpblJlc3VsdHMuVW5rbm93bkVycm9yKTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlTG9naW5SZXN1bHQoc2NyYXBlcjogQmFzZVNjcmFwZXJXaXRoQnJvd3NlciwgbG9naW5SZXN1bHQ6IExvZ2luUmVzdWx0cykge1xuICBzd2l0Y2ggKGxvZ2luUmVzdWx0KSB7XG4gICAgY2FzZSBMb2dpblJlc3VsdHMuU3VjY2VzczpcbiAgICAgIHNjcmFwZXIuZW1pdFByb2dyZXNzKFNjYXBlclByb2dyZXNzVHlwZXMuTG9naW5TdWNjZXNzKTtcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfTtcbiAgICBjYXNlIExvZ2luUmVzdWx0cy5JbnZhbGlkUGFzc3dvcmQ6XG4gICAgY2FzZSBMb2dpblJlc3VsdHMuVW5rbm93bkVycm9yOlxuICAgICAgc2NyYXBlci5lbWl0UHJvZ3Jlc3MoU2NhcGVyUHJvZ3Jlc3NUeXBlcy5Mb2dpbkZhaWxlZCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3JUeXBlOiBsb2dpblJlc3VsdCA9PT0gTG9naW5SZXN1bHRzLkludmFsaWRQYXNzd29yZCA/IFNjcmFwZXJFcnJvclR5cGVzLkludmFsaWRQYXNzd29yZCA6XG4gICAgICAgICAgU2NyYXBlckVycm9yVHlwZXMuR2VuZXJhbCxcbiAgICAgICAgZXJyb3JNZXNzYWdlOiBgTG9naW4gZmFpbGVkIHdpdGggJHtsb2dpblJlc3VsdH0gZXJyb3JgLFxuICAgICAgfTtcbiAgICBjYXNlIExvZ2luUmVzdWx0cy5DaGFuZ2VQYXNzd29yZDpcbiAgICAgIHNjcmFwZXIuZW1pdFByb2dyZXNzKFNjYXBlclByb2dyZXNzVHlwZXMuQ2hhbmdlUGFzc3dvcmQpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yVHlwZTogU2NyYXBlckVycm9yVHlwZXMuQ2hhbmdlUGFzc3dvcmQsXG4gICAgICB9O1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuZXhwZWN0ZWQgbG9naW4gcmVzdWx0IFwiJHtsb2dpblJlc3VsdH1cImApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUdlbmVyYWxFcnJvcigpOiBTY2FwZXJTY3JhcGluZ1Jlc3VsdCB7XG4gIHJldHVybiB7XG4gICAgc3VjY2VzczogZmFsc2UsXG4gICAgZXJyb3JUeXBlOiBTY3JhcGVyRXJyb3JUeXBlcy5HZW5lcmFsLFxuICB9O1xufVxuXG5jbGFzcyBCYXNlU2NyYXBlcldpdGhCcm93c2VyIGV4dGVuZHMgQmFzZVNjcmFwZXIge1xuICAvLyBOT1RJQ0UgLSBpdCBpcyBkaXNjb3VyYWdlIHRvIHVzZSBiYW5nICghKSBpbiBnZW5lcmFsLiBJdCBpcyB1c2VkIGhlcmUgYmVjYXVzZVxuICAvLyBhbGwgdGhlIGNsYXNzZXMgdGhhdCBpbmhlcml0IGZyb20gdGhpcyBiYXNlIGFzc3VtZSBpcyBpdCBtYW5kYXRvcnkuXG4gIHByb3RlY3RlZCBicm93c2VyITogQnJvd3NlcjtcblxuICAvLyBOT1RJQ0UgLSBpdCBpcyBkaXNjb3VyYWdlIHRvIHVzZSBiYW5nICghKSBpbiBnZW5lcmFsLiBJdCBpcyB1c2VkIGhlcmUgYmVjYXVzZVxuICAvLyBhbGwgdGhlIGNsYXNzZXMgdGhhdCBpbmhlcml0IGZyb20gdGhpcyBiYXNlIGFzc3VtZSBpcyBpdCBtYW5kYXRvcnkuXG4gIHByb3RlY3RlZCBwYWdlITogUGFnZTtcblxuICBhc3luYyBpbml0aWFsaXplKCkge1xuICAgIGRlYnVnKCdpbml0aWFsaXplIHNjcmFwZXInKTtcbiAgICB0aGlzLmVtaXRQcm9ncmVzcyhTY2FwZXJQcm9ncmVzc1R5cGVzLkluaXRpYWxpemluZyk7XG5cbiAgICBsZXQgZW52OiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkO1xuICAgIGlmICh0aGlzLm9wdGlvbnMudmVyYm9zZSkge1xuICAgICAgZW52ID0geyBERUJVRzogJyonLCAuLi5wcm9jZXNzLmVudiB9O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmJyb3dzZXIgIT09ICd1bmRlZmluZWQnICYmIHRoaXMub3B0aW9ucy5icm93c2VyICE9PSBudWxsKSB7XG4gICAgICBkZWJ1ZygndXNlIGN1c3RvbSBicm93c2VyIGluc3RhbmNlIHByb3ZpZGVkIGluIG9wdGlvbnMnKTtcbiAgICAgIHRoaXMuYnJvd3NlciA9IHRoaXMub3B0aW9ucy5icm93c2VyO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBleGVjdXRhYmxlUGF0aCA9IHRoaXMub3B0aW9ucy5leGVjdXRhYmxlUGF0aCB8fCB1bmRlZmluZWQ7XG4gICAgICBjb25zdCBhcmdzID0gdGhpcy5vcHRpb25zLmFyZ3MgfHwgW107XG5cbiAgICAgIGNvbnN0IGhlYWRsZXNzID0gIXRoaXMub3B0aW9ucy5zaG93QnJvd3NlcjtcbiAgICAgIGRlYnVnKGBsYXVuY2ggYSBicm93c2VyIHdpdGggaGVhZGxlc3MgbW9kZSA9ICR7aGVhZGxlc3N9YCk7XG4gICAgICB0aGlzLmJyb3dzZXIgPSBhd2FpdCBwdXBwZXRlZXIubGF1bmNoKHtcbiAgICAgICAgZW52LFxuICAgICAgICBoZWFkbGVzcyxcbiAgICAgICAgZXhlY3V0YWJsZVBhdGgsXG4gICAgICAgIGFyZ3MsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnByZXBhcmVCcm93c2VyKSB7XG4gICAgICBkZWJ1ZygnZXhlY3V0ZSBcXCdwcmVwYXJlQnJvd3NlclxcJyBpbnRlcmNlcHRvciBwcm92aWRlZCBpbiBvcHRpb25zJyk7XG4gICAgICBhd2FpdCB0aGlzLm9wdGlvbnMucHJlcGFyZUJyb3dzZXIodGhpcy5icm93c2VyKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuYnJvd3Nlcikge1xuICAgICAgZGVidWcoJ2ZhaWxlZCB0byBpbml0aWF0ZSBhIGJyb3dzZXIsIGV4aXQnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBwYWdlcyA9IGF3YWl0IHRoaXMuYnJvd3Nlci5wYWdlcygpO1xuICAgIGlmIChwYWdlcy5sZW5ndGgpIHtcbiAgICAgIGRlYnVnKCdicm93c2VyIGhhcyBhbHJlYWR5IHBhZ2VzIG9wZW4sIHVzZSB0aGUgZmlyc3Qgb25lJyk7XG4gICAgICBbdGhpcy5wYWdlXSA9IHBhZ2VzO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1ZygnY3JlYXRlIGEgbmV3IGJyb3dzZXIgcGFnZScpO1xuICAgICAgdGhpcy5wYWdlID0gYXdhaXQgdGhpcy5icm93c2VyLm5ld1BhZ2UoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnByZXBhcmVQYWdlKSB7XG4gICAgICBkZWJ1ZygnZXhlY3V0ZSBcXCdwcmVwYXJlUGFnZVxcJyBpbnRlcmNlcHRvciBwcm92aWRlZCBpbiBvcHRpb25zJyk7XG4gICAgICBhd2FpdCB0aGlzLm9wdGlvbnMucHJlcGFyZVBhZ2UodGhpcy5wYWdlKTtcbiAgICB9XG5cbiAgICBkZWJ1Zyhgc2V0IHZpZXdwb3J0IHRvIHdpZHRoICR7VklFV1BPUlRfV0lEVEh9LCBoZWlnaHQgJHtWSUVXUE9SVF9IRUlHSFR9YCk7XG4gICAgYXdhaXQgdGhpcy5wYWdlLnNldFZpZXdwb3J0KHtcbiAgICAgIHdpZHRoOiBWSUVXUE9SVF9XSURUSCxcbiAgICAgIGhlaWdodDogVklFV1BPUlRfSEVJR0hULFxuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgbmF2aWdhdGVUbyh1cmw6IHN0cmluZywgcGFnZT86IFBhZ2UsIHRpbWVvdXQ/OiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBwYWdlVG9Vc2UgPSBwYWdlIHx8IHRoaXMucGFnZTtcblxuICAgIGlmICghcGFnZVRvVXNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgb3B0aW9ucyA9IHsgLi4uKHRpbWVvdXQgPT09IG51bGwgPyBudWxsIDogeyB0aW1lb3V0IH0pIH07XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBwYWdlVG9Vc2UuZ290byh1cmwsIG9wdGlvbnMpO1xuXG4gICAgLy8gbm90ZTogcmVzcG9uc2Ugd2lsbCBiZSBudWxsIHdoZW4gbmF2aWdhdGluZyB0byBzYW1lIHVybCB3aGlsZSBjaGFuZ2luZyB0aGUgaGFzaCBwYXJ0LiB0aGUgY29uZGl0aW9uIGJlbG93IHdpbGwgYWx3YXlzIGFjY2VwdCBudWxsIGFzIHZhbGlkIHJlc3VsdC5cbiAgICBpZiAocmVzcG9uc2UgIT09IG51bGwgJiYgKHJlc3BvbnNlID09PSB1bmRlZmluZWQgfHwgcmVzcG9uc2Uuc3RhdHVzKCkgIT09IE9LX1NUQVRVUykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3Igd2hpbGUgdHJ5aW5nIHRvIG5hdmlnYXRlIHRvIHVybCAke3VybH1gKTtcbiAgICB9XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gIGdldExvZ2luT3B0aW9ucyhfY3JlZGVudGlhbHM6IFNjcmFwZXJDcmVkZW50aWFscyk6IExvZ2luT3B0aW9ucyB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBnZXRMb2dpbk9wdGlvbnMoKSBpcyBub3QgY3JlYXRlZCBpbiAke3RoaXMub3B0aW9ucy5jb21wYW55SWR9YCk7XG4gIH1cblxuICBhc3luYyBmaWxsSW5wdXRzKHBhZ2VPckZyYW1lOiBQYWdlIHwgRnJhbWUsIGZpZWxkczogeyBzZWxlY3Rvcjogc3RyaW5nLCB2YWx1ZTogc3RyaW5nfVtdKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgbW9kaWZpZWQgPSBbLi4uZmllbGRzXTtcbiAgICBjb25zdCBpbnB1dCA9IG1vZGlmaWVkLnNoaWZ0KCk7XG5cbiAgICBpZiAoIWlucHV0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGF3YWl0IGZpbGxJbnB1dChwYWdlT3JGcmFtZSwgaW5wdXQuc2VsZWN0b3IsIGlucHV0LnZhbHVlKTtcbiAgICBpZiAobW9kaWZpZWQubGVuZ3RoKSB7XG4gICAgICBhd2FpdCB0aGlzLmZpbGxJbnB1dHMocGFnZU9yRnJhbWUsIG1vZGlmaWVkKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBsb2dpbihjcmVkZW50aWFsczogUmVjb3JkPHN0cmluZywgc3RyaW5nPik6IFByb21pc2U8U2NhcGVyU2NyYXBpbmdSZXN1bHQ+IHtcbiAgICBpZiAoIWNyZWRlbnRpYWxzIHx8ICF0aGlzLnBhZ2UpIHtcbiAgICAgIHJldHVybiBjcmVhdGVHZW5lcmFsRXJyb3IoKTtcbiAgICB9XG5cbiAgICBkZWJ1ZygnZXhlY3V0ZSBsb2dpbiBwcm9jZXNzJyk7XG4gICAgY29uc3QgbG9naW5PcHRpb25zID0gdGhpcy5nZXRMb2dpbk9wdGlvbnMoY3JlZGVudGlhbHMpO1xuXG4gICAgaWYgKGxvZ2luT3B0aW9ucy51c2VyQWdlbnQpIHtcbiAgICAgIGRlYnVnKCdzZXQgY3VzdG9tIHVzZXIgYWdlbnQgcHJvdmlkZWQgaW4gb3B0aW9ucycpO1xuICAgICAgYXdhaXQgdGhpcy5wYWdlLnNldFVzZXJBZ2VudChsb2dpbk9wdGlvbnMudXNlckFnZW50KTtcbiAgICB9XG5cbiAgICBkZWJ1ZygnbmF2aWdhdGUgdG8gbG9naW4gdXJsJyk7XG4gICAgYXdhaXQgdGhpcy5uYXZpZ2F0ZVRvKGxvZ2luT3B0aW9ucy5sb2dpblVybCk7XG4gICAgaWYgKGxvZ2luT3B0aW9ucy5jaGVja1JlYWRpbmVzcykge1xuICAgICAgZGVidWcoJ2V4ZWN1dGUgXFwnY2hlY2tSZWFkaW5lc3NcXCcgaW50ZXJjZXB0b3IgcHJvdmlkZWQgaW4gbG9naW4gb3B0aW9ucycpO1xuICAgICAgYXdhaXQgbG9naW5PcHRpb25zLmNoZWNrUmVhZGluZXNzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnKCd3YWl0IHVudGlsIHN1Ym1pdCBidXR0b24gaXMgYXZhaWxhYmxlJyk7XG4gICAgICBhd2FpdCB3YWl0VW50aWxFbGVtZW50Rm91bmQodGhpcy5wYWdlLCBsb2dpbk9wdGlvbnMuc3VibWl0QnV0dG9uU2VsZWN0b3IpO1xuICAgIH1cblxuICAgIGxldCBsb2dpbkZyYW1lT3JQYWdlOiAoUGFnZSB8IEZyYW1lIHwgbnVsbCkgPSB0aGlzLnBhZ2U7XG4gICAgaWYgKGxvZ2luT3B0aW9ucy5wcmVBY3Rpb24pIHtcbiAgICAgIGRlYnVnKCdleGVjdXRlIFxcJ3ByZUFjdGlvblxcJyBpbnRlcmNlcHRvciBwcm92aWRlZCBpbiBsb2dpbiBvcHRpb25zJyk7XG4gICAgICBsb2dpbkZyYW1lT3JQYWdlID0gYXdhaXQgbG9naW5PcHRpb25zLnByZUFjdGlvbigpIHx8IHRoaXMucGFnZTtcbiAgICB9XG5cbiAgICBkZWJ1ZygnZmlsbCBsb2dpbiBjb21wb25lbnRzIGlucHV0IHdpdGggcmVsZXZhbnQgdmFsdWVzJyk7XG4gICAgYXdhaXQgdGhpcy5maWxsSW5wdXRzKGxvZ2luRnJhbWVPclBhZ2UsIGxvZ2luT3B0aW9ucy5maWVsZHMpO1xuICAgIGRlYnVnKCdjbGljayBvbiBsb2dpbiBzdWJtaXQgYnV0dG9uJyk7XG4gICAgYXdhaXQgY2xpY2tCdXR0b24obG9naW5GcmFtZU9yUGFnZSwgbG9naW5PcHRpb25zLnN1Ym1pdEJ1dHRvblNlbGVjdG9yKTtcbiAgICB0aGlzLmVtaXRQcm9ncmVzcyhTY2FwZXJQcm9ncmVzc1R5cGVzLkxvZ2dpbmdJbik7XG5cbiAgICBpZiAobG9naW5PcHRpb25zLnBvc3RBY3Rpb24pIHtcbiAgICAgIGRlYnVnKCdleGVjdXRlIFxcJ3Bvc3RBY3Rpb25cXCcgaW50ZXJjZXB0b3IgcHJvdmlkZWQgaW4gbG9naW4gb3B0aW9ucycpO1xuICAgICAgYXdhaXQgbG9naW5PcHRpb25zLnBvc3RBY3Rpb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWcoJ3dhaXQgZm9yIHBhZ2UgbmF2aWdhdGlvbicpO1xuICAgICAgYXdhaXQgd2FpdEZvck5hdmlnYXRpb24odGhpcy5wYWdlKTtcbiAgICB9XG5cbiAgICBkZWJ1ZygnY2hlY2sgbG9naW4gcmVzdWx0Jyk7XG4gICAgY29uc3QgY3VycmVudCA9IGF3YWl0IGdldEN1cnJlbnRVcmwodGhpcy5wYWdlLCB0cnVlKTtcbiAgICBjb25zdCBsb2dpblJlc3VsdCA9IGF3YWl0IGdldEtleUJ5VmFsdWUobG9naW5PcHRpb25zLnBvc3NpYmxlUmVzdWx0cywgY3VycmVudCwgdGhpcy5wYWdlKTtcbiAgICBkZWJ1ZyhgaGFuZGxlIGxvZ2luIHJlc3VsdHMgJHtsb2dpblJlc3VsdH1gKTtcbiAgICByZXR1cm4gaGFuZGxlTG9naW5SZXN1bHQodGhpcywgbG9naW5SZXN1bHQpO1xuICB9XG5cbiAgYXN5bmMgdGVybWluYXRlKF9zdWNjZXNzOiBib29sZWFuKSB7XG4gICAgZGVidWcoYHRlcm1pbmF0aW5nIGJyb3dzZXIgd2l0aCBzdWNjZXNzID0gJHtfc3VjY2Vzc31gKTtcbiAgICB0aGlzLmVtaXRQcm9ncmVzcyhTY2FwZXJQcm9ncmVzc1R5cGVzLlRlcm1pbmF0aW5nKTtcblxuICAgIGlmICghX3N1Y2Nlc3MgJiYgISF0aGlzLm9wdGlvbnMuc3RvcmVGYWlsdXJlU2NyZWVuU2hvdFBhdGgpIHtcbiAgICAgIGRlYnVnKGBjcmVhdGUgYSBzbmFwc2hvdCBiZWZvcmUgdGVybWluYXRlZCBpbiAke3RoaXMub3B0aW9ucy5zdG9yZUZhaWx1cmVTY3JlZW5TaG90UGF0aH1gKTtcbiAgICAgIGF3YWl0IHRoaXMucGFnZS5zY3JlZW5zaG90KHtcbiAgICAgICAgcGF0aDogdGhpcy5vcHRpb25zLnN0b3JlRmFpbHVyZVNjcmVlblNob3RQYXRoLFxuICAgICAgICBmdWxsUGFnZTogdHJ1ZSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5icm93c2VyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgYXdhaXQgdGhpcy5icm93c2VyLmNsb3NlKCk7XG4gIH1cbn1cblxuZXhwb3J0IHsgQmFzZVNjcmFwZXJXaXRoQnJvd3NlciB9O1xuIl19